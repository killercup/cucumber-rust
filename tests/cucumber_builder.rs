#![feature(async_await)]

extern crate cucumber_rust as cucumber;
use cucumber::{after, before, cucumber};

#[derive(Clone)]
pub struct MyWorld {
    // You can use this struct for mutable context in scenarios.
    foo: String,
}

impl cucumber::World for MyWorld {}
impl std::default::Default for MyWorld {
    fn default() -> MyWorld {
        // This function is called every time a new scenario is started
        MyWorld {
            foo: "a default string".to_string(),
        }
    }
}

mod example_steps {
    use cucumber::{typed_regex, Steps, StepsBuilder};
    use std::pin::Pin;

    use std::panic::{AssertUnwindSafe, UnwindSafe};
    use futures::future::{Future, BoxFuture, FutureExt};

    async fn a_thing(world: crate::MyWorld, step: cucumber::Step) -> () {
        runtime::time::Delay::new(std::time::Duration::from_millis(2000)).await;
        panic!("OH NO");
    }

    fn a_thing2(world: crate::MyWorld, step: cucumber::Step) -> cucumber::TestFuture {
        cucumber::TestFuture::new(a_thing(world, step))
    }

    pub fn steps() -> Steps<crate::MyWorld> {
        let mut builder: StepsBuilder<crate::MyWorld> = StepsBuilder::new();

        builder
            .given_async("a thing", a_thing2)
            .given("I am trying out Cucumber", |world, _step| {
                world.foo = "Some string".to_string();
            })
            .when("I consider what I am doing", |world, _step| {
                let new_string = format!("{}.", &world.foo);
                world.foo = new_string;
            })
            .then("I am interested in ATDD", |world, _step| {
                assert_eq!(world.foo, "Some string.");
            })
            .then_regex(
                r"^we can (.*) rules with regex$",
                |_world, matches, _step| {
                    // And access them as an array
                    assert_eq!(matches[1], "implement");
                },
            )
            .then_regex(
                r"^we can also match (\d+) (.+) types$",
                typed_regex!(
                    crate::MyWorld,
                    (usize, String) | _world,
                    num,
                    word,
                    _step | {
                        // `num` will be of type usize, `word` of type String
                        assert_eq!(num, 42);
                        assert_eq!(word, "olika");
                    }
                ),
            );

        builder.build()
    }

    // Any type that implements cucumber::World + Default can be the world
    // steps!(crate::MyWorld => {
    //     given "I am trying out Cucumber" |world, _step| {
    //         world.foo = "Some string".to_string();
    //         // Set up your context in given steps
    //     };

    //     when "I consider what I am doing" |world, _step| {
    //         // Take actions
    //         let new_string = format!("{}.", &world.foo);
    //         world.foo = new_string;
    //     };

    //     then "I am interested in ATDD" |world, _step| {
    //         // Check that the outcomes to be observed have occurred
    //         assert_eq!(world.foo, "Some string.");
    //     };

    //     then regex r"^we can (.*) rules with regex$" |_world, matches, _step| {
    //         // And access them as an array
    //         assert_eq!(matches[1], "implement");
    //     };

    //     then regex r"^we can also match (\d+) (.+) types$" (usize, String) |_world, num, word, _step| {
    //         // `num` will be of type usize, `word` of type String
    //         assert_eq!(num, 42);
    //         assert_eq!(word, "olika");
    //     };

    //     then "we can use data tables to provide more parameters" |_world, step| {
    //         let table = step.table().unwrap().clone();

    //         assert_eq!(table.header, vec!["key", "value"]);

    //         let expected_keys = table.rows.iter().map(|row| row[0].to_owned()).collect::<Vec<_>>();
    //         let expected_values = table.rows.iter().map(|row| row[1].to_owned()).collect::<Vec<_>>();

    //         assert_eq!(expected_keys, vec!["a", "b"]);
    //         assert_eq!(expected_values, vec!["fizz", "buzz"]);
    //     };
    // });
}

// Declares a before handler function named `a_before_fn`
before!(a_before_fn => |_scenario| {

});

// Declares an after handler function named `an_after_fn`
after!(an_after_fn => |_scenario| {

});

// A setup function to be called before everything else
fn setup() {}

cucumber! {
    features: "./features", // Path to our feature files
    world: ::MyWorld, // The world needs to be the same for steps and the main cucumber call
    steps: &[
        example_steps::steps // the `steps!` macro creates a `steps` function in a module
    ],
    setup: setup, // Optional; called once before everything
    before: &[
        a_before_fn // Optional; called before each scenario
    ],
    after: &[
        an_after_fn // Optional; called after each scenario
    ]
}
